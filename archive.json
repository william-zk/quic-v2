{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2022-01-13T00:30:35.003775+00:00",
  "repo": "quicwg/quic-v2",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    }
  ],
  "issues": [
    {
      "number": 1,
      "id": "MDU6SXNzdWU4NjUyODQ1Nzc=",
      "title": "Add a provisional version",
      "url": "https://github.com/quicwg/quic-v2/issues/1",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Because VN is still a moving target, and the WG might want to increase the diff from v1, the draft should specify an experimental version number to use until RFC, at which point we can switch over to 0x00000002.",
      "createdAt": "2021-04-22T18:19:48Z",
      "updatedAt": "2021-04-23T21:05:21Z",
      "closedAt": "2021-04-23T21:05:21Z",
      "comments": [
        {
          "author": "huitema",
          "authorAssociation": "NONE",
          "body": "Yes. Something like \"0xFF0100nn\"...",
          "createdAt": "2021-04-23T19:41:14Z",
          "updatedAt": "2021-04-23T19:41:14Z"
        }
      ]
    },
    {
      "number": 2,
      "id": "MDU6SXNzdWU4NjYzODU0MzU=",
      "title": "Retry protection key",
      "url": "https://github.com/quicwg/quic-v2/issues/2",
      "state": "CLOSED",
      "author": "huitema",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The draft defines a V2 salt. Should it also define a V2 retry protection key?",
      "createdAt": "2021-04-23T19:45:48Z",
      "updatedAt": "2021-04-26T19:28:16Z",
      "closedAt": "2021-04-26T19:28:16Z",
      "comments": []
    },
    {
      "number": 3,
      "id": "MDU6SXNzdWU4NjgwNzI2NDA=",
      "title": "Update Labels",
      "url": "https://github.com/quicwg/quic-v2/issues/3",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "We can get complete key separation between quic v1 and v2 by simply changing the labels used as HKDF inputs.",
      "createdAt": "2021-04-26T19:31:43Z",
      "updatedAt": "2021-04-26T19:56:58Z",
      "closedAt": "2021-04-26T19:56:58Z",
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "COLLABORATOR",
          "body": "9.6 of quic-tls says we should, so this is inflight.",
          "createdAt": "2021-04-26T19:46:25Z",
          "updatedAt": "2021-04-26T19:46:25Z"
        }
      ]
    },
    {
      "number": 4,
      "id": "MDU6SXNzdWU4NjkzMzQxMDI=",
      "title": "Different version number",
      "url": "https://github.com/quicwg/quic-v2/issues/4",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "@martinthomson wants to use some other version number, not 2. I'd have to retitle the draft, but other than that I don't have a strong feeling about it.",
      "createdAt": "2021-04-27T23:06:09Z",
      "updatedAt": "2021-04-28T16:04:49Z",
      "closedAt": "2021-04-28T16:04:49Z",
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "COLLABORATOR",
          "body": "Upon further reflection, this is a pretty fundamental question: are QUIC versions incremental, where in general version N comes after N-1 and is implied to be \"better\", or are they randomly spread over the space with no clear temporal or quality relationship?",
          "createdAt": "2021-04-28T04:35:31Z",
          "updatedAt": "2021-04-28T04:35:31Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "MEMBER",
          "body": "> are QUIC versions incremental, where in general version N comes after N-1 and is implied to be \"better\", or are they randomly spread over the space with no clear temporal or quality relationship?\r\n\r\nI think this is the framing that we should use for reaching a resolution.\r\n\r\nThe reason we chose \"HTTP/3\" as the name for the HTTP binding for QUIC is because people tend to believe that increments on version number represent something better. It'd be hard if not impossible to change that perception.\r\n\r\nComparing to that, this \"v2\" draft is not something meant to be better than v1 - it is merely an alternative wire encoding of v1.\r\n\r\nBased on that, I tend to agree with @martinthomson; it would be less confusing to people if we choose a large random number than \"v2.\"",
          "createdAt": "2021-04-28T04:46:09Z",
          "updatedAt": "2021-04-28T04:46:09Z"
        }
      ]
    },
    {
      "number": 5,
      "id": "MDU6SXNzdWU4Njk0ODEwNTI=",
      "title": "ALPN",
      "url": "https://github.com/quicwg/quic-v2/issues/5",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "on slack some are saying we should roll a new h3 ALPN for running over quicv2. I cannot quite follow the argument but this is a better venue for the discussion.",
      "createdAt": "2021-04-28T04:26:07Z",
      "updatedAt": "2021-06-02T18:22:48Z",
      "closedAt": "2021-06-02T18:22:48Z",
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "body": "You definitely need a new specification, because a different QUIC version might not be suitable.  You either say:\r\n\r\n* h3 can be used with QUICv2, or\r\n* h3q2 (or whatever new string you like) identifies HTTP/3 when running over QUICv2.\r\n\r\nThere are lots of arguments as to why you might choose to do one or the other.",
          "createdAt": "2021-04-28T04:33:18Z",
          "updatedAt": "2021-04-28T04:33:18Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "I'm swayed more toward a new ALP.N at the moment ",
          "createdAt": "2021-04-28T11:34:38Z",
          "updatedAt": "2021-04-28T11:34:38Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "FWIW we painted ourselves into this corner. We punting on the problem and simply tied H3 to v1. Now we are actively trying to solve VN we might be able to pay back the tech debt. For example, a document that updates H3 to say that it can work over versions compatible with v1. Incompatible versions could still need to defined as a new application mapping,",
          "createdAt": "2021-04-28T12:44:35Z",
          "updatedAt": "2021-04-28T12:44:35Z"
        },
        {
          "author": "RyanTheOptimist",
          "authorAssociation": "NONE",
          "body": "Whatever we do, I think we need to ensure that servers can give sufficient information to clients via Alt-Svc so that the client can pick a compatible version (if any) and avoid VN. This could, then, be solved via Alt-Svc layer or via ALPN, but I think this is any important property.",
          "createdAt": "2021-04-28T18:39:05Z",
          "updatedAt": "2021-04-28T18:39:05Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "COLLABORATOR",
          "body": "Well \"avoiding VN\" is only important to the extent that we can't do compatible VN.",
          "createdAt": "2021-04-28T18:50:54Z",
          "updatedAt": "2021-04-28T18:50:54Z"
        },
        {
          "author": "RyanTheOptimist",
          "authorAssociation": "NONE",
          "body": "I think we want to allow the existence of a server that only supports v2 and servers that only support v1.... and clients that only support v2 and clients that only support v1. Given this, there will be client : server pairs which do not support any mutually compatible options. It seems like it would be desirable for clients to be able to deduce this from Alt-Svc without needing to see the QUIC connection to the server fail?",
          "createdAt": "2021-04-28T19:54:30Z",
          "updatedAt": "2021-04-28T19:54:30Z"
        },
        {
          "author": "RyanTheOptimist",
          "authorAssociation": "NONE",
          "body": "Oh, and this text from the HTTP/3 docs is probably relevant:\r\n\r\n>    HTTP/3 relies on QUIC version 1 as the underlying transport.  The use\r\n>    of other QUIC transport versions with HTTP/3 MAY be defined by future\r\n>    specifications.\r\n",
          "createdAt": "2021-04-28T21:17:16Z",
          "updatedAt": "2021-04-28T21:17:16Z"
        }
      ]
    },
    {
      "number": 7,
      "id": "MDU6SXNzdWU4NzExODMzOTg=",
      "title": "Grease the packet type?",
      "url": "https://github.com/quicwg/quic-v2/issues/7",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "It would be a simple matter to switch around the packet type codes in long headers, e.g.\r\n\r\n0x0 = Retry\r\n0x1 = Handshake\r\n0x2 = 0-RTT\r\n0x3 = Initial\r\n\r\nso no one ossifies on 0x0 = Initial.",
      "createdAt": "2021-04-29T15:58:09Z",
      "updatedAt": "2022-01-12T16:26:32Z",
      "closedAt": "2022-01-12T16:26:32Z",
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "body": "I'm ambivalent on this.  It's fairly trivial to have the long header parsed in version-specific fashion, so it's easy to implement, but I'm not sure how much value it has.  It also makes reading packets slightly harder.",
          "createdAt": "2022-01-05T04:22:48Z",
          "updatedAt": "2022-01-05T04:22:48Z"
        }
      ]
    },
    {
      "number": 9,
      "id": "I_kwDOFX7TQc4-mBKB",
      "title": "Don't Change Labels",
      "url": "https://github.com/quicwg/quic-v2/issues/9",
      "state": "CLOSED",
      "author": "nibanks",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "> The labels used in {{RFC9001}} to derive packet protection keys (Sec 5.1), header protection keys (Sec 5.4), Retry Integrity Tag keys (Sec 5.8), and key updates (Sec 6.1) change from \"quic key\" to \"quicv2 key\", from \"quic iv\" to \"quicv2 iv\", from \"quic hp\" to \"quicv2 hp\", and from \"quic ku\" to \"quicv2 ku,\" to meet the guidance for new versions in Section 9.6 of that document.\r\n\r\nDo we really need to change the labels? This will be a much bigger pain for me to integrate beyond the normal salt and retry secret changes that we regularly did for draft versions. What added benefit are the label changes giving?",
      "createdAt": "2021-11-10T18:15:31Z",
      "updatedAt": "2022-01-11T17:14:13Z",
      "closedAt": "2022-01-11T17:14:13Z",
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "COLLABORATOR",
          "body": "https://www.rfc-editor.org/rfc/rfc9001.html#key-diversity\r\n\r\nit's a SHOULD",
          "createdAt": "2021-11-10T18:22:14Z",
          "updatedAt": "2021-11-10T18:22:14Z"
        },
        {
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "body": "Ok. It's probably worth some more discussion. Personally, I'd rather follow the model we set with draft versions. At least, that's what MsQuic is setup to easily handle.",
          "createdAt": "2021-11-10T18:24:39Z",
          "updatedAt": "2021-11-10T18:24:39Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "body": "This SHOULD is important; it will help keep your KDF from atrophy.  It was a little annoying to implement for me, but not overly so.\r\n\r\n(Note that we have transcript diversity by virtue of including the version negotiation transport parameters, but I don't think that is sufficient.)\r\n\r\n@nibanks, is this still a problem?",
          "createdAt": "2022-01-11T00:47:32Z",
          "updatedAt": "2022-01-11T00:47:32Z"
        },
        {
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "body": "It's an annoyance more than a problem. Our per-version abstraction will have to be modified to account for this, if we go forward with it, adding additional complexity.",
          "createdAt": "2022-01-11T00:52:25Z",
          "updatedAt": "2022-01-11T00:52:25Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "body": "Yeah, I can sympathize.  It was annoying to implement across an abstraction boundary for us also.  Luckily, we don't have to manage independent release cycles or anything truly awkward there.",
          "createdAt": "2022-01-11T01:02:12Z",
          "updatedAt": "2022-01-11T01:02:12Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't think anyone is strenuously objecting to the current design; closing",
          "createdAt": "2022-01-11T17:14:13Z",
          "updatedAt": "2022-01-11T17:14:13Z"
        }
      ]
    },
    {
      "number": 10,
      "id": "I_kwDOFX7TQc4-ukxt",
      "title": "Applicability of extensions",
      "url": "https://github.com/quicwg/quic-v2/issues/10",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The draft should state explicitly that all v1 extensions can be applied to v2 connections.",
      "createdAt": "2021-11-12T20:46:59Z",
      "updatedAt": "2021-11-22T23:06:26Z",
      "closedAt": "2021-11-22T23:06:26Z",
      "comments": []
    },
    {
      "number": 14,
      "id": "I_kwDOFX7TQc4_jV8O",
      "title": "Clarify about cross version 0-RTT via Compatible Version Negotiation",
      "url": "https://github.com/quicwg/quic-v2/issues/14",
      "state": "CLOSED",
      "author": "flano-yuki",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Thank you for this work.\r\n\r\nCan quic v2 server accept a v1 0-RTT packet via Compatible Version Negotiation?\r\n\r\nIf I understand correctly, The [version negotiation specification](https://quicwg.org/version-negotiation/draft-ietf-quic-version-negotiation.html#name-interaction-with-0-rtt) says that \"future versions will determine how to handle it.\" Even if the server accepts v1 packets as is, I would think the handling needs to be described in v2.",
      "createdAt": "2021-11-29T16:17:06Z",
      "updatedAt": "2022-01-07T20:29:43Z",
      "closedAt": "2022-01-07T20:29:43Z",
      "comments": [
        {
          "author": "kazu-yamamoto",
          "authorAssociation": "NONE",
          "body": "Developers are actually puzzled.\r\nSee https://github.com/quicwg/version-negotiation/issues/68",
          "createdAt": "2021-12-02T00:59:05Z",
          "updatedAt": "2021-12-02T00:59:05Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "body": "Moving the discussion here, I think that 0-RTT is not as clear-cut as it seems.\r\n\r\nWhen doing a compatible upgrade from v1 to v2, a server makes the switch when it processes the ClientHello (that is, all Initial packets from the client to a first approximation).  It is relatively easy for the server to make the switch cleanly at that point because it doesn't need to read any more Initial packets and all other packets will be v2 from then on.\r\n\r\nA client makes the switch based on seeing a v2 packet.  It might receive some v1 Initial packets, but the one containing a ServerHello will be v2.  If the client is sending 0-RTT packets, it might need to send them until it receives all of the Handshake packets from the server.  That is, it might be some time.\r\n\r\nFor a client in that state, it doesn't really make sense to switch to sending v2 0-RTT packets, but if it doesn't it will be intermixing transmission of v1 0-RTT packets and v2 Handshake packets.  This is awkward because there is no clean cut-over.\r\n\r\nIn my implementation, I also have to deal with stack integration issues that make installing the right 0-RTT keys difficult.\r\n\r\nI ultimately opted to just reject 0-RTT if there was a version change.  The number of cases in which you might want to use 0-RTT and you don't already know what version the server wants to use are very limited.  Basically, this only happens if you are doing 0-RTT across an upgrade of the server.  Losing 0-RTT in that case seems tolerable.",
          "createdAt": "2022-01-05T06:08:11Z",
          "updatedAt": "2022-01-05T06:08:11Z"
        }
      ]
    },
    {
      "number": 15,
      "id": "I_kwDOFX7TQc4_2rCC",
      "title": "Need to specify the update process",
      "url": "https://github.com/quicwg/quic-v2/issues/15",
      "state": "CLOSED",
      "author": "huitema",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "We now have some implementation experience, and got interop between 2 implementations. That's great, but the process was difficult because the transition is somehow under specified. There was a lot of discussion as issues with the compatible version negotiation draft:\r\n\r\n* [Specify impact on 0-RTT, session resume tickets, etc.](https://github.com/quicwg/version-negotiation/issues/68)\r\n* [Security issue when upgrading based on received version in header](https://github.com/quicwg/version-negotiation/issues/70)\r\n* [Validation on incompatible negotiation](https://github.com/quicwg/version-negotiation/issues/73)\r\n\r\nThese issues cannot be fully addressed in the compatible version negotiation draft, which has to be version independent. Instead, they need to be addressed in specific drafts. The V2 draft, for example, should specify exactly what happens during the version negotiation. My understanding is that when version negotiation succeeds, we will see something like:\r\n\r\n- Client sends a first flight composed of Version 1 initial packets\r\n- Server may send Version 1 initial packets containing acknowledgement, e.g., to manage losses of Initial packets\r\n- At some point, the server will have received and parsed the transport parameters, and decided to upgrade to V2\r\n- After that point, server will send version 2 packets (Initial, Handshake, 1RTT)\r\n- Client will receive version 2 packets and should be ready to process them before the negotiation completes\r\n- The transport parameters will arrive in V2 handshake packets, after which the negotiation is done.\r\n\r\nThere are quite a few potential issues that need resolution:\r\n\r\n1) As explained above, in case of successful negotiation, the client expects the server to start sending V2 packets asap. Shall it ignore V1 packets as soon as it received V2 packets? Should in check version numbers in Initial packets, in a process similar to key updates?\r\n2) If the client receives transport parameters on a version 2 packet, what shall it do if the chosen version is V1?\r\n3) And vice versa?\r\n4) If the server receives V2 handshake packets from the client, shall it conclude that the negotiation is successful?\r\n5) In case of session resumption, does the client resume using V1 or V2? I think the answer to that question depends on the content of the \"supported versions\" list provided by the server. If it includes V2, then the server is ready to receive V2 packets. If the server is part of a server farm with partial deployment of V2, it should not say that V2 is ready. The answer may also depend on local conditions at the client.\r\n6) If the client resumes using V1, it will send 0-RTT packets using V1. The server will receive these packets after the client's initial packets, and thus after receiving the transport parameters and completing the version upgrade. Should the server drop these packets? Or should it continue accept them until the handshake completes?\r\n7) On the client side, there will be a delay between completing the negotiation and finalizing the handshake. The client may want to send 0-RTT packets during that interval. Shall it send those using V1 or V2?\r\n\r\n\r\n",
      "createdAt": "2021-12-04T21:14:50Z",
      "updatedAt": "2022-01-07T20:29:43Z",
      "closedAt": "2022-01-07T20:29:43Z",
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "COLLABORATOR",
          "body": "The most literal answer to your question is, \"of course all v1 can be interchanged with v2, since they're identical\". But I'm going to answer the more interesting question of what precise questions a new version has to answer.\r\n\r\nAFAICT, in the v1->v2 case, (assuming all the support is present) there are four possible responses from the server:\r\n1) a v2 Initial with ACK and/or ServerHello\r\n2) a v1 Initial with ACK, followed by a v2 Initial with ServerHello\r\n3) a v1 Retry (a v2 Retry would also be correct, but silly for the server to do things that way)\r\n4) a v1 Initial with ACK, followed by nothing (because some of the client hello was lost)\r\nI believe this generalizes to all transitions v1->v_n.\r\n\r\nSo clearly the client can't draw any conclusions about the ultimate version until it sees the server hello, or a v2 packet of any kind. It can't fully authenticate the handshake until we get 1-RTT keys.\r\n\r\nSo to answer your questions:\r\n(1) yes, ignore v1 once you get v2 -- you don't need the Initial ACK anyway\r\n(2) and (3) if the chosen version in the TP doesn't match the QUIC header, this is a VN violation, no? Shouldn't this be handled in the VN draft?\r\n(4) I would think that any client packet with v2 and the correct keys would do the trick.\r\n(5) The two elements of this are the NEW_TOKEN token and the TLS session ticket. The hard part here is that the contents of this are not in any version spec; if QUIC and TLS implementations put version specific things in there, then it won't work. IIUC in general the session ticket wouldn't include anything derived from the version-dependent HKDF labels, so it ought to work.\r\n(6) and (7) I believe the server has to handle v1 0RTT till the handshake is over, as it can't guarantee that 0RTT arriving after the 2nd flight was sent after that flight. The client could switch its 0RTT to v2 once negotiated -- I have no strong opinion if that complexity is worthwhile.\r\n\r\nI don't think putting these responses in a PR is the right move -- I'd like to clarify what properly should go in the VN draft and what should rest here.",
          "createdAt": "2021-12-07T20:23:46Z",
          "updatedAt": "2021-12-07T20:23:46Z"
        },
        {
          "author": "kazu-yamamoto",
          "authorAssociation": "NONE",
          "body": "> (1) yes, ignore v1 once you get v2 -- you don't need the Initial ACK anyway\r\n\r\nMinor fix. In @huitema's example, ACK in V1 from the server is received by the client before any V2 packets. So, the client can handle it anyway.",
          "createdAt": "2021-12-08T01:47:33Z",
          "updatedAt": "2021-12-08T01:47:33Z"
        },
        {
          "author": "kazu-yamamoto",
          "authorAssociation": "NONE",
          "body": "> (6) and (7) I believe the server has to handle v1 0RTT till the handshake is over, as it can't guarantee that 0RTT arriving after the 2nd flight was sent after that flight. The client could switch its 0RTT to v2 once negotiated -- I have no strong opinion if that complexity is worthwhile.\r\n\r\nThis is probably a good idea. We can say that 0RTT belongs to the previous connection of V1.\r\n\r\n@huitema If you agree, let's implement this and do interop.",
          "createdAt": "2021-12-08T01:51:00Z",
          "updatedAt": "2021-12-08T01:51:00Z"
        },
        {
          "author": "kazu-yamamoto",
          "authorAssociation": "NONE",
          "body": "> a v1 Retry (a v2 Retry would also be correct, but silly for the server to do things that way)\r\n\r\nWe need to prohibit v2 Retry since a v1-only client cannot retry if v2 Retry is received.",
          "createdAt": "2021-12-08T01:57:44Z",
          "updatedAt": "2021-12-08T01:57:44Z"
        },
        {
          "author": "kazu-yamamoto",
          "authorAssociation": "NONE",
          "body": "> If the client receives transport parameters on a version 2 packet, what shall it do if the chosen version is V1?\r\n\r\nWhen a client see V2 in a long header, it switches to V2 keys. This switch is allowed only once. After handshake is completed, the client checks if the version for keys and Chosen Version is the same.",
          "createdAt": "2021-12-08T02:01:13Z",
          "updatedAt": "2021-12-08T02:01:13Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "NONE",
          "body": "OK, I will test the 0-RTT part internally first. There are timing issues in the server code, depending on whether the 0-RTT key is produced before the negotiation or after it.",
          "createdAt": "2021-12-08T05:55:37Z",
          "updatedAt": "2021-12-08T05:55:37Z"
        },
        {
          "author": "kazu-yamamoto",
          "authorAssociation": "NONE",
          "body": "@huitema The idea for 0-RTT works perfectly on my local tests. I will brush up the code tomorrow and set up a public server.",
          "createdAt": "2021-12-08T06:50:22Z",
          "updatedAt": "2021-12-08T06:50:22Z"
        }
      ]
    },
    {
      "number": 17,
      "id": "I_kwDOFX7TQc5ABJPl",
      "title": "Test vectors",
      "url": "https://github.com/quicwg/quic-v2/issues/17",
      "state": "OPEN",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "RFC 9001 had 'em and they were very helpful.\r\n\r\nYou might find [this script](https://gist.github.com/martinthomson/1f000d3e389b0bf1308e1043e141fbb9) to be useful.",
      "createdAt": "2021-12-08T05:59:38Z",
      "updatedAt": "2021-12-08T06:01:37Z",
      "closedAt": null,
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "body": "Note that the TLS messages in that script hasn't been changed to include the version negotiation transport parameters.  If you want to publish it, then you'll need to work out how to do that, sorry.",
          "createdAt": "2021-12-08T06:01:36Z",
          "updatedAt": "2021-12-08T06:01:36Z"
        }
      ]
    },
    {
      "number": 20,
      "id": "I_kwDOFX7TQc5BMmLL",
      "title": "Request provisional version number allocation",
      "url": "https://github.com/quicwg/quic-v2/issues/20",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Get one from IANA",
      "createdAt": "2022-01-04T23:00:59Z",
      "updatedAt": "2022-01-12T16:23:31Z",
      "closedAt": "2022-01-12T16:23:31Z",
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "COLLABORATOR",
          "body": "I'll ask for 0x70 9a 50 c4 .",
          "createdAt": "2022-01-04T23:01:44Z",
          "updatedAt": "2022-01-04T23:01:44Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "body": "Feedback from @DavidSchinazi was that you should do that after publishing a revision with that number in it.  I second that.",
          "createdAt": "2022-01-11T00:48:08Z",
          "updatedAt": "2022-01-11T00:48:08Z"
        }
      ]
    },
    {
      "number": 21,
      "id": "I_kwDOFX7TQc5BMmti",
      "title": "Packet injection during Compatible VN",
      "url": "https://github.com/quicwg/quic-v2/issues/21",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "There might be security considerations related to injecting packets during compatible VN. They may not be worse than other Initial injection attacks, but think it through.",
      "createdAt": "2022-01-04T23:05:12Z",
      "updatedAt": "2022-01-11T17:13:23Z",
      "closedAt": "2022-01-11T17:13:23Z",
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "body": "The only packets that a client might accept are in versions that are compatible and supported by the client.\r\n\r\nIn practice however, a client will accept packets in any version prior to fixating on a version.  My implementation will accept any compatible version for Initial packets until it receives a CRYPTO frame, at which point it fixates on that version.  That means that what it will accept is limited to ACKs and path validation.  Any attack on these can be mounted on a single QUIC version without compatible version negotiation.\r\n\r\nIf a compatible version is broken and the client is willing to use that version, then it will be vulnerable to attack.  That's the new attack here.",
          "createdAt": "2022-01-11T00:55:04Z",
          "updatedAt": "2022-01-11T00:55:04Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "COLLABORATOR",
          "body": "I believe this is correct.",
          "createdAt": "2022-01-11T17:13:23Z",
          "updatedAt": "2022-01-11T17:13:23Z"
        }
      ]
    },
    {
      "number": 23,
      "id": "I_kwDOFX7TQc5BM45Y",
      "title": "Retry and compatible upgrade",
      "url": "https://github.com/quicwg/quic-v2/issues/23",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "It is necessary to specify how retry works when a compatible upgrade is used.\r\n\r\nThe easiest way to specify this is to say that Retry can be sent in version 1, but the validation is performed as though a version 2 retry was sent.  That's what I've seen implemented thus far.",
      "createdAt": "2022-01-05T01:40:11Z",
      "updatedAt": "2022-01-12T22:58:19Z",
      "closedAt": "2022-01-12T22:58:19Z",
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "COLLABORATOR",
          "body": "Here's the relevant text in your PR (numbers mine) \r\n(1) A server SHOULD produce a Retry packet in the same version as the Initial packet\r\nthat the Retry packet responds to.  (2) Validation of the Retry exchange uses the\r\nlogic of the final negotiated version, treating the Retry as if it were sent in\r\nthat version. (3) This means that the version used for Retry is not authenticated,\r\nonly that it occurred and the connection ID that was used.\r\n\r\n(1) I made it a MUST in the recent merge, to make it a bit easier for clients.\r\n\r\n(2) I'm not really sure what this means in the context of v1/v2 -- the logic is identical in both cases. Maybe this is something for the v1->vn text (pending) in the VN doc? But yeah, anything in the client hello, including the retry TPs, are processed syntactically as v1  but the content is used for v2 purposes. Do I understand the takeaway correctly?\r\n\r\n(3) This is a fair point to make, I guess: the Retry logic only ever measured that the CIDs matched. But, meh? The client changing the version between connection attempts would be strange, but legal and not obviously dangerous. If you think this sentence is valuable, I can add it.\r\n\r\n\r\n\r\n",
          "createdAt": "2022-01-07T21:12:12Z",
          "updatedAt": "2022-01-07T21:12:12Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "body": "1. Fine.\r\n2. Yeah, this was just a wording choice of mine.  I do think that the validation is an important point to be clear on, lest people decide to skip it.  I don't think that this can be part of the VN document at least as it stands as the Retry mechanism is version-specific and so any handling of it also needs to be.\r\n3. This is really just noting the limitations of the validation.  I don't think that it has security consequences, particularly if the client enforces the requirement that Retry use the original version (which, presumably they are permitted to... by dropping the packet).",
          "createdAt": "2022-01-11T01:01:22Z",
          "updatedAt": "2022-01-11T01:01:22Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "COLLABORATOR",
          "body": "https://github.com/quicwg/version-negotiation/issues/78 is going to introduce some considerations specific to v1. Nevertheless, I'm happy to write something down here.",
          "createdAt": "2022-01-11T15:31:43Z",
          "updatedAt": "2022-01-11T15:31:43Z"
        }
      ]
    },
    {
      "number": 25,
      "id": "I_kwDOFX7TQc5BhrZq",
      "title": "MUST fully support VN is too strong",
      "url": "https://github.com/quicwg/quic-v2/issues/25",
      "state": "CLOSED",
      "author": "DavidSchinazi",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The draft currently states:\r\n> QUIC version 2 endpoints SHOULD also support QUIC version 1. Any QUIC endpoint that supports multiple versions MUST fully implement [QUIC-VN] to prevent version downgrade attacks.\r\n\r\nI think we should weaken this to only require the downgrade prevention aspect of QUIC-VN. Chrome doesn't currently support incompatible version negotiation and we don't plan to change that when we add support for v2.",
      "createdAt": "2022-01-11T16:02:37Z",
      "updatedAt": "2022-01-12T20:11:37Z",
      "closedAt": "2022-01-12T20:11:37Z",
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree that 'fully support' is too onerous. However, it is not really clear to me what the minimum set of VN support is. The VN draft doesn't really envision partial support.\r\n\r\nIf a client includes the version information TP, it MUST support compatible negotiation. A server that sends VN packets (as they all should!) MUST support incompatible negotiation.\r\n\r\nSo for clients, AFAICT there are three levels of support:\r\n1) No support: do not the send the TP. If you get a VN packet, switch to TCP\r\n2) Compatible only - send the TP, be prepared to accept an upgrade\r\n3) Full: respond to VN packets with incompatible negotiation.\r\n\r\nFor servers, it would be\r\n1) Send the TP and support incompatible negotiation\r\n2) Support compatible negotiation",
          "createdAt": "2022-01-11T17:12:14Z",
          "updatedAt": "2022-01-11T17:12:14Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "NONE",
          "body": "> If a client includes the version information TP, it MUST support compatible negotiation.\r\n\r\nI don't think that's right. The client can just always send `Other Versions = (Chosen Version)`\r\n\r\nTherefore, for clients, the options are:\r\n1. No support: do not the send nor parse the TP. If you get a VN packet, fail the QUIC connection\r\n1. Downgrade prevention only: send the TP with only one other version, also parse and validate the TP. If you get a VN packet, fail the QUIC connection\r\n1. Compatible only: downgrade prevention and be prepared to accept an upgrade\r\n1. Incompatible only: downgrade prevention and retry with new version when receiving VN\r\n1. Full: downgrade prevention, compatible VN and incompatible VN\r\n\r\nI agree with what you said about servers.",
          "createdAt": "2022-01-11T17:56:59Z",
          "updatedAt": "2022-01-11T17:56:59Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't understand 2. If only one version is advertised, what downgrade are we preventing?\r\n\r\nAlso, I don't see how (4) works if the server decides to do a compatible VN. Is the idea that the client only advertises support for one version in its TP?",
          "createdAt": "2022-01-11T18:09:34Z",
          "updatedAt": "2022-01-11T18:14:26Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "NONE",
          "body": "> I don't understand 2. If only one version is advertised, what downgrade are we preventing?\r\n\r\nLet's say the client tries version B and the server supports both versions A and B. An active network attacker can intercept the client's version B packets and rewrite them as version A before forwarding them to the server - then you would end up with a connection where the client thinks it's speaking version B and the server thinks it's speaking version A. If version A is vulnerable to an attack that B isn't, the attacker managed to downgrade the security from version B to version A. In practice this attack doesn't work with v1 and v2 because we changed the HKDF labels, but the attack could work on other versions.\r\n\r\nThis entire class of problem goes away if you add the Chosen Version to the TLS transcript, so there's some value in the downgrade-prevention-only mode.\r\n\r\n> Also, I don't see how (4) works if the server decides to do a compatible VN. Is the idea that the client only advertises support for one version in its TP?\r\n\r\nThat's right.",
          "createdAt": "2022-01-11T18:21:02Z",
          "updatedAt": "2022-01-11T18:21:02Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "COLLABORATOR",
          "body": "(2) Offline, David clarified that the attack doesn't work in v1/v2 because the handshake packets authenticate the version field. but this is not generalizable to all QUIC versions.\r\n\r\nas for (4), thanks, makes sense.\r\n",
          "createdAt": "2022-01-11T18:34:13Z",
          "updatedAt": "2022-01-11T18:34:13Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "COLLABORATOR",
          "body": "I filed https://github.com/quicwg/version-negotiation/issues/80.\r\n\r\nI think the right language for this draft is something to the effect of \"Endpoints that support multiple versions MUST meet the minimum requirements described in {{QUIC-VN}}.\"",
          "createdAt": "2022-01-11T18:36:49Z",
          "updatedAt": "2022-01-11T18:36:49Z"
        }
      ]
    },
    {
      "number": 30,
      "id": "I_kwDOFX7TQc5BnPOq",
      "title": "HTTP/3 over QUICv2",
      "url": "https://github.com/quicwg/quic-v2/issues/30",
      "state": "OPEN",
      "author": "DavidSchinazi",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "At IETF 106, [we decided](https://github.com/quicwg/base-drafts/pull/3323) that HTTP/3 only runs over QUICv1. draft-ietf-quic-http still states `HTTP/3 relies on QUIC version 1 as the underlying transport`. Since that document is the reference in the ALPN registry for the ALPN string \"h3\", that means that `Alt-Svc: h3` is formally defined as \"HTTP/3 over QUICv1\". And that's exactly what all major browsers have implemented: if they see \"h3\" in Alt-Svc, they will send a QUICv1 initial.\r\n\r\nSeparately, the QUICv2 draft currently does not mention \"h3\" or HTTP/3 at all. If we were to publish QUICv2 as-is, that would mean that the only way that QUICv2 would ever be used with HTTP/3 would be for clients to send a QUICv1 initial and then have the server perform [compatible version negotiation](https://datatracker.ietf.org/doc/html/draft-ietf-quic-version-negotiation-05#section-4.3) from v1 to v2. That also means that QUICv2 endpoints will forever need to support QUICv1. That doesn't sound ideal.\r\n\r\nThis has been discussed before [on the list](https://mailarchive.ietf.org/arch/msg/quic/VuAWMvB8XFjpfK7kg6QaHn4KHqA/) and [at IETF 111](https://www.youtube.com/watch?v=R7q8cWIAIDQ&t=6262s) but we never reached consensus on a path forward.\r\n\r\nHere are the options I see:\r\n\r\n1. Leave everything as-is, and accept that QUICv2 requires QUICv1 and compatible version negotiation\r\n2. Mint a new ALPN (e.g. \"h3q2\") that means \"HTTP/3 over QUICv2\" and can be used in Alt-Svc\r\n3. Add a new parameter to Alt-Svc entries that specific the QUIC version (though servers would still need to support QUICv1 for old clients that don't know the parameter)\r\n\r\nGiven that we won't be minting that many QUIC versions, one new h3 ALPN per version seems simplest to me.\r\n\r\nFor what it's worth, I feel strongly that we should get WG consensus on the path forward here before we start the WGLC on QUICv2.",
      "createdAt": "2022-01-12T21:27:27Z",
      "updatedAt": "2022-01-12T22:33:24Z",
      "closedAt": null,
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Wearing no hats, option 2 is similar to how deployment have already approached supporting H3 over different QUIC v1 draft versions (albeit a bit implicitly. Something like \"h3q2<-appended draft version>\" would allow us to work on this until we are happy to mint a QUIC v2 RFC.\r\n\r\nI would like to note though that a proliferation of tokens to be used in Alt-Svc does have practical implications for Multi-CDN scenarios https://github.com/httpwg/http-extensions/issues/1673. That might be a problem that we just need to let the HTTP WG figure out though. \r\n\r\nOf the three options here, 2) seems strongest to me.",
          "createdAt": "2022-01-12T21:54:20Z",
          "updatedAt": "2022-01-12T21:54:20Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "COLLABORATOR",
          "body": "Beyond a potential explosion in ALPN registry entries, I see this as creating major obstacles to introducing and deprecating versions, if there are use cases besides h3.\r\n\r\nAfter all, a sensible QUIC implementation will accept its ALPN code from the application running on top of it. If I want to roll out a new QUIC version in a protocol implementation, any application running over it also needs to modify its code to use that version. If I want to get rid of a bad version, I have to change all the applications to truly get rid of it.\r\n\r\nCertainly, anything is scalable if we have a handful of ALPNs and versions. But this is an important tradeoff.\r\n\r\nI'd prefer (3) -- Lucas, perhaps I don't understand the MultiCDN objection, but isn't a version-specific ALPN equally awkward for a MultiCDN rollout?",
          "createdAt": "2022-01-12T22:19:18Z",
          "updatedAt": "2022-01-12T22:19:18Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "NONE",
          "body": "This isn't about ALPN, it's really specific to Alt-Svc which is specific to HTTP. Use-cases beyond h3 don't need a new ALPN.",
          "createdAt": "2022-01-12T22:25:44Z",
          "updatedAt": "2022-01-12T22:25:44Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "COLLABORATOR",
          "body": "> This isn't about ALPN, it's really specific to Alt-Svc which is specific to HTTP. Use-cases beyond h3 don't need a new ALPN.\r\n\r\nHmm, that substantially reduces my objection. I can live with that consensus, and if there is one we should get it in the applicability doc.",
          "createdAt": "2022-01-12T22:29:57Z",
          "updatedAt": "2022-01-12T22:29:57Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Yeah sorry, David expressed it better than me. I should clarify that both options 2 and 3 have impact on Alt-Svc.\r\n\r\nTo add to my preference on option 2. Anything that uses ALPN for reporting or logging (such as the Web's resource timing nextHopProtocol) can benefit from information encoded in the ALPN ID itself. No extra work needed to encode transport-level details. ",
          "createdAt": "2022-01-12T22:33:24Z",
          "updatedAt": "2022-01-12T22:33:24Z"
        }
      ]
    }
  ],
  "pulls": [
    {
      "number": 6,
      "id": "MDExOlB1bGxSZXF1ZXN0NjI1MzcxNjkz",
      "title": "alpn text",
      "url": "https://github.com/quicwg/quic-v2/pull/6",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "One way to fix #5 ",
      "createdAt": "2021-04-28T16:18:08Z",
      "updatedAt": "2021-06-02T18:22:48Z",
      "baseRepository": "quicwg/quic-v2",
      "baseRefName": "main",
      "baseRefOid": "eb1b70ee4e069483599e798a9432bc1fc7c7a120",
      "headRepository": "quicwg/quic-v2",
      "headRefName": "alpn",
      "headRefOid": "9e74378765f92e4dd7d1da6897cf6241ec7cd8b5",
      "closedAt": "2021-06-02T18:22:48Z",
      "mergedAt": "2021-06-02T18:22:48Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "0abe99f92456b09314e786b6e271bcec66ce76d5"
      },
      "comments": [
        {
          "author": "MikeBishop",
          "authorAssociation": "NONE",
          "body": "I have a feeling you'll need to say that this \"updates\" HTTP/3.",
          "createdAt": "2021-04-28T20:55:36Z",
          "updatedAt": "2021-04-28T20:55:36Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 8,
      "id": "MDExOlB1bGxSZXF1ZXN0NjYwMjkxMzE5",
      "title": "sync with main",
      "url": "https://github.com/quicwg/quic-v2/pull/8",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-06-02T18:21:50Z",
      "updatedAt": "2021-06-02T18:23:33Z",
      "baseRepository": "quicwg/quic-v2",
      "baseRefName": "alpn",
      "baseRefOid": "9e74378765f92e4dd7d1da6897cf6241ec7cd8b5",
      "headRepository": "quicwg/quic-v2",
      "headRefName": "main",
      "headRefOid": "0abe99f92456b09314e786b6e271bcec66ce76d5",
      "closedAt": "2021-06-02T18:23:33Z",
      "mergedAt": "2021-06-02T18:23:33Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "68020698e4d9fe9db02478ff6751fb474b3a5534"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 11,
      "id": "PR_kwDOFX7TQc4u4M6d",
      "title": "convert filename to -ietf",
      "url": "https://github.com/quicwg/quic-v2/pull/11",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-11-22T22:53:42Z",
      "updatedAt": "2022-01-04T21:19:41Z",
      "baseRepository": "quicwg/quic-v2",
      "baseRefName": "main",
      "baseRefOid": "79f0607cbbf8331a6ee6d2705fa00ca39909d49d",
      "headRepository": "quicwg/quic-v2",
      "headRefName": "update-name",
      "headRefOid": "030e4774e787009a9ad6cfd9c6fec7981bbb11ca",
      "closedAt": "2021-11-22T22:54:37Z",
      "mergedAt": "2021-11-22T22:54:37Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "88132694f806e3a1ed76e5d3a4cef05eb565b42c"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 12,
      "id": "PR_kwDOFX7TQc4u4OZW",
      "title": "Fix #10: support all extensions",
      "url": "https://github.com/quicwg/quic-v2/pull/12",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-11-22T23:05:40Z",
      "updatedAt": "2022-01-04T21:19:42Z",
      "baseRepository": "quicwg/quic-v2",
      "baseRefName": "main",
      "baseRefOid": "a834768d2dddaab2b77478e3bb4b9b68be4c0fd4",
      "headRepository": "quicwg/quic-v2",
      "headRefName": "extensions",
      "headRefOid": "420ffc320bf70441b6f18de0af2cec3ef0ccdffe",
      "closedAt": "2021-11-22T23:06:25Z",
      "mergedAt": "2021-11-22T23:06:25Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "287bdcf88a2ff8fdb257ef6d8e60b59d62ad0421"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 13,
      "id": "PR_kwDOFX7TQc4u7Fp3",
      "title": "Fix typo in Key Updates label",
      "url": "https://github.com/quicwg/quic-v2/pull/13",
      "state": "MERGED",
      "author": "IvanNardi",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-11-23T18:35:53Z",
      "updatedAt": "2021-11-23T18:51:15Z",
      "baseRepository": "quicwg/quic-v2",
      "baseRefName": "main",
      "baseRefOid": "9d29f07d8743238c363c278c68f72715c5efec5b",
      "headRepository": "IvanNardi/quic-v2",
      "headRefName": "key-update",
      "headRefOid": "64ac9f36cae4ec2057485ef65b81a65f8b2df1dd",
      "closedAt": "2021-11-23T18:43:15Z",
      "mergedAt": "2021-11-23T18:43:14Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "4557dc73f1b3caa8f7b81077791babd6d6f5f153"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFX7TQc4whW_k",
          "commit": {
            "abbreviatedOid": "64ac9f3"
          },
          "author": "martinduke",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-11-23T18:41:37Z",
          "updatedAt": "2021-11-23T18:41:37Z",
          "comments": []
        }
      ]
    },
    {
      "number": 16,
      "id": "PR_kwDOFX7TQc4viLq5",
      "title": "Semi-automatic update of venue information",
      "url": "https://github.com/quicwg/quic-v2/pull/16",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-12-08T05:00:29Z",
      "updatedAt": "2021-12-08T05:03:29Z",
      "baseRepository": "quicwg/quic-v2",
      "baseRefName": "main",
      "baseRefOid": "4557dc73f1b3caa8f7b81077791babd6d6f5f153",
      "headRepository": "martinthomson/quic-v2",
      "headRefName": "venue",
      "headRefOid": "8fb8a54a80a4160e3eed2210cca624315096409b",
      "closedAt": "2021-12-08T05:03:29Z",
      "mergedAt": "2021-12-08T05:03:29Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "a9ffd031aa43cd913b9b7b3d5e1dbdee8ad8a93e"
      },
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "body": "(If you are looking to do this for yourself on other repos, you can copy the venue fields from https://github.com/martinthomson/internet-draft-template/blob/main/draft-todo-yourname-protocol.md into your draft and run `make update-venue`.)",
          "createdAt": "2021-12-08T05:01:22Z",
          "updatedAt": "2021-12-08T05:01:22Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 18,
      "id": "PR_kwDOFX7TQc4wh8yj",
      "title": "change author affiliation",
      "url": "https://github.com/quicwg/quic-v2/pull/18",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-01-04T21:13:38Z",
      "updatedAt": "2022-01-04T21:19:39Z",
      "baseRepository": "quicwg/quic-v2",
      "baseRefName": "main",
      "baseRefOid": "a9ffd031aa43cd913b9b7b3d5e1dbdee8ad8a93e",
      "headRepository": "quicwg/quic-v2",
      "headRefName": "author",
      "headRefOid": "ba2723ed32b526669e18dc92a05f8e030881761b",
      "closedAt": "2022-01-04T21:18:17Z",
      "mergedAt": "2022-01-04T21:18:17Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "4e7ae98a2ec5089139693b7135a0ebcbc5177c0c"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 19,
      "id": "PR_kwDOFX7TQc4wiJlU",
      "title": "Rules for compatible VN",
      "url": "https://github.com/quicwg/quic-v2/pull/19",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #14 and fixes #15.\r\n\r\nI could be persuaded that some of the choices made here are not the best.",
      "createdAt": "2022-01-04T22:58:16Z",
      "updatedAt": "2022-01-12T17:19:54Z",
      "baseRepository": "quicwg/quic-v2",
      "baseRefName": "main",
      "baseRefOid": "4e7ae98a2ec5089139693b7135a0ebcbc5177c0c",
      "headRepository": "quicwg/quic-v2",
      "headRefName": "update-narrative",
      "headRefOid": "5cfe3115d2587d83f554b9d1d6c8ae8517c43fa1",
      "closedAt": "2022-01-07T20:29:43Z",
      "mergedAt": "2022-01-07T20:29:43Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "201b8b779c9bf2091b6a2ae083deeaad29929c5b"
      },
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "body": "Oops, I posted #24, which is almost exactly the same.  My bad.\r\n\r\nThe 0-RTT thing is one I might contest here.  It is possible to accept 0-RTT if you have a compatible upgrade, but I'm not sure that you ever need it.  The situations in which you can use 0-RTT without knowing what version is in use are few.  All the client has to do is remember the negotiated version from last time and use that version.",
          "createdAt": "2022-01-05T03:00:39Z",
          "updatedAt": "2022-01-05T03:00:39Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "COLLABORATOR",
          "body": "I take it we've reached rough consensus that 0RTT has value, though no one will force MT to accept those packets.\r\n\r\nI'm going to merge this, and fix #23 in a separate PR (taking text from #24)",
          "createdAt": "2022-01-07T20:29:37Z",
          "updatedAt": "2022-01-07T20:29:37Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOFX7TQc4yT7U-",
          "commit": {
            "abbreviatedOid": "5cfe311"
          },
          "author": "huitema",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "The text reflects the consensus so far. I have to update my implementation to ensure that it follows these rules exactly, in particular for 0RTT, might add comments when that implementation is tested.",
          "createdAt": "2022-01-04T23:04:56Z",
          "updatedAt": "2022-01-04T23:04:56Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOFX7TQc4ykyIq",
          "commit": {
            "abbreviatedOid": "5cfe311"
          },
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-11T00:58:40Z",
          "updatedAt": "2022-01-11T01:15:17Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "I would prefer:\r\n\r\n> Before the server is able to process transport parameters from the client, it might need to respond to Initial packets from the client. For these packets the server uses the original version.",
              "createdAt": "2022-01-11T00:58:40Z",
              "updatedAt": "2022-01-11T01:15:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFX7TQc4ytejk",
          "commit": {
            "abbreviatedOid": "5cfe311"
          },
          "author": "martinduke",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-12T17:19:54Z",
          "updatedAt": "2022-01-12T17:19:54Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "Thanks, made the change here: https://github.com/quicwg/quic-v2/commit/f3f21c846d978c66e5cb5643cdf4c1978e2d0c69",
              "createdAt": "2022-01-12T17:19:54Z",
              "updatedAt": "2022-01-12T17:19:54Z"
            }
          ]
        }
      ]
    },
    {
      "number": 22,
      "id": "PR_kwDOFX7TQc4wiZd4",
      "title": "Improve cross referencing",
      "url": "https://github.com/quicwg/quic-v2/pull/22",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "This uses kramdown tricks to make real links for the section references\r\nto RFC 9001 and uses a nicer label for those.",
      "createdAt": "2022-01-05T01:37:37Z",
      "updatedAt": "2022-01-05T02:51:15Z",
      "baseRepository": "quicwg/quic-v2",
      "baseRefName": "main",
      "baseRefOid": "4e7ae98a2ec5089139693b7135a0ebcbc5177c0c",
      "headRepository": "martinthomson/quic-v2",
      "headRefName": "xrefs",
      "headRefOid": "9b7450a80cd33ea93f81756cbe75b7443a895a50",
      "closedAt": "2022-01-05T02:51:15Z",
      "mergedAt": "2022-01-05T02:51:15Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "a28650478ef0dc3886d786ba31b810ec3fc830de"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFX7TQc4yURPY",
          "commit": {
            "abbreviatedOid": "9b7450a"
          },
          "author": "martinduke",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-01-05T02:51:05Z",
          "updatedAt": "2022-01-05T02:51:05Z",
          "comments": []
        }
      ]
    },
    {
      "number": 24,
      "id": "PR_kwDOFX7TQc4wibB1",
      "title": "What I learned about compatible versions",
      "url": "https://github.com/quicwg/quic-v2/pull/24",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "This is what the version negotiation draft requires of a document that\r\ndefines compatible version negotiation.  The answers I've used here are\r\nbased on my own experience implementing this.  Others might have a\r\ndifferent experience.\r\n\r\nCloses #23.",
      "createdAt": "2022-01-05T01:58:15Z",
      "updatedAt": "2022-01-12T22:59:17Z",
      "baseRepository": "quicwg/quic-v2",
      "baseRefName": "main",
      "baseRefOid": "4e7ae98a2ec5089139693b7135a0ebcbc5177c0c",
      "headRepository": "martinthomson/quic-v2",
      "headRefName": "vn",
      "headRefOid": "38717e81b0b7c83204ed75ac4b33e34802e7fe36",
      "closedAt": "2022-01-12T22:59:17Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "body": "@huitema, does this match your understanding?",
          "createdAt": "2022-01-05T01:59:06Z",
          "updatedAt": "2022-01-05T01:59:06Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "COLLABORATOR",
          "body": "Oh, I see the Retry bit now",
          "createdAt": "2022-01-05T03:27:12Z",
          "updatedAt": "2022-01-05T03:27:12Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "COLLABORATOR",
          "body": "I believe #19 and #26 handled this with similar text",
          "createdAt": "2022-01-12T22:59:17Z",
          "updatedAt": "2022-01-12T22:59:17Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOFX7TQc4yURs8",
          "commit": {
            "abbreviatedOid": "38717e8"
          },
          "author": "martinduke",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Huh. #19 and #24 post the same day. @huitema suggested #19 matches his experience.\r\n\r\nAlso, this doesn't seem to address the bit about Retry validation in #23?\r\n\r\nTomorrow I can see if there's anything to synthesize between the two.",
          "createdAt": "2022-01-05T02:56:29Z",
          "updatedAt": "2022-01-05T02:56:29Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOFX7TQc4yURxM",
          "commit": {
            "abbreviatedOid": "38717e8"
          },
          "author": "martinduke",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-05T02:57:17Z",
          "updatedAt": "2022-01-05T02:58:02Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "Given the differing labels, all the protection is different, no?",
              "createdAt": "2022-01-05T02:57:17Z",
              "updatedAt": "2022-01-05T02:58:02Z"
            },
            {
              "originalPosition": 40,
              "body": "Is there a reason for this? It seems like a disincentive to upgrade.",
              "createdAt": "2022-01-05T02:57:58Z",
              "updatedAt": "2022-01-05T02:58:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFX7TQc4yUSKC",
          "commit": {
            "abbreviatedOid": "38717e8"
          },
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-05T03:01:28Z",
          "updatedAt": "2022-01-05T03:01:28Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "Good point.",
              "createdAt": "2022-01-05T03:01:28Z",
              "updatedAt": "2022-01-05T03:01:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFX7TQc4yUSiM",
          "commit": {
            "abbreviatedOid": "38717e8"
          },
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-05T03:05:19Z",
          "updatedAt": "2022-01-05T03:05:19Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "Maybe.  Though the number of cases where you get to deploy a whole new version and continue to use 0-RTT across the upgrade is small.  You will mostly have a previous connection in the negotiated version, so you can remember which was used and attempt that straight up.  It is only during the rollout of v2 that you need to worry about maybe accepting v2 and rejecting 0-RTT.\r\n\r\nIn our stack, it is completely non-trivial to calculate v1 0-RTT keys once you have negotiated v2.  Given how narrow the applicability is, it seems much safer to reject.\r\n\r\nOf course, you could just make rejection discretionary.",
              "createdAt": "2022-01-05T03:05:19Z",
              "updatedAt": "2022-01-05T03:05:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFX7TQc4yUVdH",
          "commit": {
            "abbreviatedOid": "38717e8"
          },
          "author": "huitema",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-05T03:42:08Z",
          "updatedAt": "2022-01-05T03:42:08Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "Let see. To Martin's point, I have only partially tested usage of 0-RTT with resumption, always resuming with V1.\r\n\r\nA server negotiates 0-RTT if it has received a session resumption ticket during the previous handshake. Session tickets are carried in crypto frames in 1-RTT packets, thus after the transport parameters have been negotiated. It seems we can have the following:\r\n\r\n1) Client initiates a V1 session, also proposes V2, server negotiates V2, indicates V2 support, and sends a resumption ticket.\r\n\r\n2) Client initiates a V1 session, also proposes V2, server negotiates V2, does not indicates V2 support, and sends a resumption ticket.\r\n\r\n3) Client initiates a V1 session, also proposes V2, server negotiates V1 and sends a resumption ticket.\r\n\r\n4) Client initiates a V1 session, does not propose alternative. Server sends a resumption ticket.\r\n\r\nIt seems to me that in case #1, the client should resume a session using V2, including for 0-RTT. In case #2, #3 and #4, it should resume using V1. Case #4 is plain V1, which implies support of 0-RTT. It would be bizarre to allow 0RTT in case #4 but not in cases #2 and #3.",
              "createdAt": "2022-01-05T03:42:08Z",
              "updatedAt": "2022-01-05T03:42:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFX7TQc4yUWHz",
          "commit": {
            "abbreviatedOid": "38717e8"
          },
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-05T03:50:00Z",
          "updatedAt": "2022-01-05T03:50:01Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "I'm not following case 2.  Did you mean that the server negotiates v2, but does not support v1?  You can't use compatible negotiation for that, I think.\r\n\r\nCases 3 and 4 are clear cut cases where the only mutually supported version is v1, just that one has VN support and the other doesn't.\r\n\r\nThe case that is potentially interesting is this: Client offers v1 and v2.  Server only supports v1 so it uses that and sends a 0-RTT-capable ticket.  Server upgrades to add v2 support.  Client then makes a new connection with v1 and 0-RTT.  Server is forced to choose between a compatible upgrade and 0-RTT.",
              "createdAt": "2022-01-05T03:50:01Z",
              "updatedAt": "2022-01-05T03:50:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFX7TQc4yXmlr",
          "commit": {
            "abbreviatedOid": "38717e8"
          },
          "author": "huitema",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-05T20:46:35Z",
          "updatedAt": "2022-01-05T20:46:36Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "The server response contains the selected version and a list of supported versions. Case #2 happens when the selected version is V2, but the list of supported versions only contains V1. That would be a reasonable thing to do by a server in a big farm. The server itself supports V2, but not all servers in the farm do, so the server is telling the client that it would be reasonable to use V1 in the new connections.",
              "createdAt": "2022-01-05T20:46:35Z",
              "updatedAt": "2022-01-05T20:46:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFX7TQc4yX8SY",
          "commit": {
            "abbreviatedOid": "38717e8"
          },
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-05T22:50:46Z",
          "updatedAt": "2022-01-05T22:50:46Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "Good point.  I missed that nuance.  That increases the potential value of doing 0-RTT in the original version.",
              "createdAt": "2022-01-05T22:50:46Z",
              "updatedAt": "2022-01-05T22:50:46Z"
            }
          ]
        }
      ]
    },
    {
      "number": 26,
      "id": "PR_kwDOFX7TQc4wzywb",
      "title": "Retry rules",
      "url": "https://github.com/quicwg/quic-v2/pull/26",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #23 ",
      "createdAt": "2022-01-11T16:21:09Z",
      "updatedAt": "2022-01-12T22:58:19Z",
      "baseRepository": "quicwg/quic-v2",
      "baseRefName": "main",
      "baseRefOid": "50fe07f8dbad88c25a272d5012487e6be1f4cc23",
      "headRepository": "quicwg/quic-v2",
      "headRefName": "retry-rules",
      "headRefOid": "e57d5793dab6b2db843b2ff8fa85d63942d07487",
      "closedAt": "2022-01-12T22:58:19Z",
      "mergedAt": "2022-01-12T22:58:19Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "bb3fc8663ccc14b9b9ec840f40add73f5edeae74"
      },
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "COLLABORATOR",
          "body": "@martinthomson fixed up IAW with your comments. PTAL",
          "createdAt": "2022-01-12T17:10:21Z",
          "updatedAt": "2022-01-12T17:10:21Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOFX7TQc4yp85p",
          "commit": {
            "abbreviatedOid": "d2aef23"
          },
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-12T00:20:18Z",
          "updatedAt": "2022-01-12T00:23:27Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "I think that you want to say what the client does with a Retry in a version other than the original: it ignores it.",
              "createdAt": "2022-01-12T00:20:18Z",
              "updatedAt": "2022-01-12T00:23:27Z"
            },
            {
              "originalPosition": 7,
              "body": "This MUST NOT doesn't really make much sense as the client won't have any information from the server that might even suggest the possibility that a different version would work.",
              "createdAt": "2022-01-12T00:21:01Z",
              "updatedAt": "2022-01-12T00:23:27Z"
            },
            {
              "originalPosition": 10,
              "body": "As noted, this is probably not really necessary, but it's fine.",
              "createdAt": "2022-01-12T00:21:24Z",
              "updatedAt": "2022-01-12T00:23:28Z"
            },
            {
              "originalPosition": 15,
              "body": "This first sentence might not be clear because it refers to text in a specific version.  Maybe you could reiterate that \"QUIC version 2 uses the same transport parameters to authenticate the Retry as QUIC version 1.\"",
              "createdAt": "2022-01-12T00:23:22Z",
              "updatedAt": "2022-01-12T00:23:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFX7TQc4ytaaZ",
          "commit": {
            "abbreviatedOid": "d2aef23"
          },
          "author": "martinduke",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-12T17:05:16Z",
          "updatedAt": "2022-01-12T17:05:16Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "I agree that this is a silly thing for the client to do, but I'm all for forbidding silly things to simplify the code. It does give the freedom for the server to have version-specific retry tokens, which is useless in v2 but probably establishes a better pattern for other versions.",
              "createdAt": "2022-01-12T17:05:16Z",
              "updatedAt": "2022-01-12T17:05:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFX7TQc4ytacy",
          "commit": {
            "abbreviatedOid": "d2aef23"
          },
          "author": "martinduke",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-12T17:05:23Z",
          "updatedAt": "2022-01-12T17:05:23Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "yep",
              "createdAt": "2022-01-12T17:05:23Z",
              "updatedAt": "2022-01-12T17:05:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFX7TQc4yupGR",
          "commit": {
            "abbreviatedOid": "0110e9f"
          },
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-12T22:54:25Z",
          "updatedAt": "2022-01-12T22:54:26Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "```suggestion\r\nin {{Section 7.3 of QUIC}}. Note that the version of the first Initial and the subsequent Retry\r\n```",
              "createdAt": "2022-01-12T22:54:26Z",
              "updatedAt": "2022-01-12T22:54:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFX7TQc4yupHR",
          "commit": {
            "abbreviatedOid": "0110e9f"
          },
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-01-12T22:54:31Z",
          "updatedAt": "2022-01-12T22:54:31Z",
          "comments": []
        }
      ]
    },
    {
      "number": 27,
      "id": "PR_kwDOFX7TQc4w0A4b",
      "title": "grease packet types",
      "url": "https://github.com/quicwg/quic-v2/pull/27",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fix #7 \r\n\r\nAlso, add structure to the \"changes from v1\" section.",
      "createdAt": "2022-01-11T17:26:50Z",
      "updatedAt": "2022-01-12T16:26:47Z",
      "baseRepository": "quicwg/quic-v2",
      "baseRefName": "main",
      "baseRefOid": "72e206c1449a253218c86721cab1e5b51f520561",
      "headRepository": "quicwg/quic-v2",
      "headRefName": "grease-type",
      "headRefOid": "7fae311a83e4c8bb5351da9e1869a171e932cb1a",
      "closedAt": "2022-01-12T16:26:32Z",
      "mergedAt": "2022-01-12T16:26:32Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "50fe07f8dbad88c25a272d5012487e6be1f4cc23"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 28,
      "id": "PR_kwDOFX7TQc4w0GIQ",
      "title": "random version number",
      "url": "https://github.com/quicwg/quic-v2/pull/28",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fix #20 ",
      "createdAt": "2022-01-11T17:53:58Z",
      "updatedAt": "2022-01-12T16:26:49Z",
      "baseRepository": "quicwg/quic-v2",
      "baseRefName": "main",
      "baseRefOid": "201b8b779c9bf2091b6a2ae083deeaad29929c5b",
      "headRepository": "quicwg/quic-v2",
      "headRefName": "new-version",
      "headRefOid": "ae95ee33ab674e57a627d0044fdaa28b2f4b8a94",
      "closedAt": "2022-01-12T16:23:31Z",
      "mergedAt": "2022-01-12T16:23:31Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "72e206c1449a253218c86721cab1e5b51f520561"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 29,
      "id": "PR_kwDOFX7TQc4w0Ood",
      "title": "Loosen requirement to support VN",
      "url": "https://github.com/quicwg/quic-v2/pull/29",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fix #25 ",
      "createdAt": "2022-01-11T18:42:47Z",
      "updatedAt": "2022-01-12T20:11:49Z",
      "baseRepository": "quicwg/quic-v2",
      "baseRefName": "main",
      "baseRefOid": "50fe07f8dbad88c25a272d5012487e6be1f4cc23",
      "headRepository": "quicwg/quic-v2",
      "headRefName": "min-vn",
      "headRefOid": "77df5a244c2c764316c0c311c83591f38f1b1301",
      "closedAt": "2022-01-12T20:11:37Z",
      "mergedAt": "2022-01-12T20:11:36Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "74b9ee7f9883a672098ec1385d2f994107eb03f9"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFX7TQc4yt5j6",
          "commit": {
            "abbreviatedOid": "77df5a2"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "It's not entirely clear what minimal support is, but we have an issue for that :-)",
          "createdAt": "2022-01-12T19:02:50Z",
          "updatedAt": "2022-01-12T19:02:50Z",
          "comments": []
        }
      ]
    }
  ]
}